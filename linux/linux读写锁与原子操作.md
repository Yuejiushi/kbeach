# linux读写锁与原子操作



| 特性               | 原子操作                                          | 读写锁                                         |
| ------------------ | ------------------------------------------------- | ---------------------------------------------- |
| **主要用途**       | 简单的并发数据访问和更新                          | 多线程读写操作的同步                           |
| **适用数据类型**   | 基本数据类型（如整数、标志位）                    | 复杂数据结构（如链表、树等）                   |
| **性能开销**       | 低，几乎没有额外的开销                            | 高，涉及锁的获取和释放                         |
| **支持的操作类型** | 简单操作（增、减、位运算等）                      | 读操作（多个线程可以并发执行）和写操作（互斥） |
| **锁争用**         | 不存在锁争用，原子操作通常非常快速                | 锁争用可能导致性能瓶颈                         |
| **复杂度**         | 实现简单，代码复杂度低                            | 实现复杂，管理读锁和写锁的逻辑                 |
| **线程安全性**     | 确保单次操作的原子性                              | 保证读操作和写操作的同步                       |
| **多线程性能**     | 适合低竞争情况下的操作                            | 适合读操作远多于写操作的情况                   |
| **适用场景**       | 计数器、标志位、简单共享状态                      | 数据库、缓存系统、复杂数据结构的访问           |
| **示例**           | `std::atomic<int> counter; counter.fetch_add(1);` | `std::shared_mutex`，`std::unique_lock`        |
| **优点**           | 几乎不产生上下文切换，效率高                      | 读操作并发，写操作互斥，适合读多写少的场景     |
| **缺点**           | 只适合简单数据类型，不适合复杂操作                | 写锁可能导致写操作延迟，读写锁管理复杂         |

**总结**

- **原子操作**：适用于简单的数据访问和更新，例如计数器、标志位等，通常在低竞争情况下性能优越，避免了锁的开销。
- **读写锁**：适用于复杂数据结构的同步，特别是当读操作远多于写操作时能够提供良好的性能保障，但读写锁的管理较复杂，并且在写操作时可能导致性能瓶颈。